From 87feae19de6abdf9efd0359637d8a23c226f1aad Mon Sep 17 00:00:00 2001
From: Aleksander Jan Bajkowski <olek2@wp.pl>
Date: Sat, 10 May 2025 11:32:22 +0200
Subject: [PATCH] r8152: test led control

Signed-off-by: Aleksander Jan Bajkowski <olek2@wp.pl>
---
 drivers/net/usb/r8152.c | 193 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 193 insertions(+)

diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c
index 2cab046749a9..62cda781cfe5 100644
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@ -26,6 +26,8 @@
 #include <linux/atomic.h>
 #include <linux/acpi.h>
 #include <linux/firmware.h>
+#include <linux/leds.h>
+#include <uapi/linux/uleds.h>
 #include <crypto/hash.h>
 #include <linux/usb/r8152.h>
 #include <net/gso.h>
@@ -356,6 +358,13 @@
 #define UWF_EN			0x0010
 #define LAN_WAKE_EN		0x0002
 
+/* PLA_LEDSEL */
+#define RTL8152_LED_CTRL_OPTION2	BIT(15)
+#define RTL8152_LED_CTRL_ACT		BIT(3)
+#define RTL8152_LED_CTRL_LINK_1000	BIT(2)
+#define RTL8152_LED_CTRL_LINK_100	BIT(1)
+#define RTL8152_LED_CTRL_LINK_10	BIT(0)
+
 /* PLA_LED_FEATURE */
 #define LED_MODE_MASK		0x0700
 
@@ -866,6 +875,14 @@ struct tx_agg {
 	u32 skb_len;
 };
 
+#define RTL8152_NUM_LEDS	3
+
+struct r8152_led_classdev {
+	struct led_classdev led;
+	struct net_device *ndev;
+	int index;
+};
+
 struct r8152 {
 	unsigned long flags;
 	struct usb_device *udev;
@@ -878,6 +895,7 @@ struct r8152 {
 	struct list_head rx_done, tx_free;
 	struct sk_buff_head tx_queue, rx_queue;
 	spinlock_t rx_lock, tx_lock;
+	struct mutex led_lock;	/* serialize LED ctrl RMW access */
 	struct delayed_work schedule, hw_phy_work;
 	struct mii_if_info mii;
 	struct mutex control;	/* use for hw setting */
@@ -960,6 +978,8 @@ struct r8152 {
 	u8 autoneg;
 
 	unsigned int reg_access_reset_count;
+
+	struct r8152_led_classdev *leds;
 };
 
 /**
@@ -7047,6 +7067,173 @@ static void rtl_tally_reset(struct r8152 *tp)
 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);
 }
 
+static int r8152_led_mod_ctrl(struct r8152 *tp, u16 mask, u16 val)
+{
+	mutex_lock(&tp->led_lock);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LEDSEL, (ocp_read_word(tp, MCU_TYPE_PLA, PLA_LEDSEL) & ~mask) | val);
+	mutex_unlock(&tp->led_lock);
+
+	return 0;
+}
+
+static int rtl8152_get_led_mode(struct r8152 *tp)
+{
+	int ret;
+
+	ret = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LEDSEL);
+
+	return ret;
+}
+
+static void r8152_get_led_name(struct r8152 *tp, int idx,
+			char *buf, int buf_len)
+{
+	snprintf(buf, buf_len, "%s-led%d::lan", tp->netdev->name, idx);
+}
+
+#define lcdev_to_r8152_ldev(lcdev) container_of(lcdev, struct r8152_led_classdev, led)
+
+static bool r8152_trigger_mode_is_valid(unsigned long flags)
+{
+	bool rx, tx;
+
+	if (flags & BIT(TRIGGER_NETDEV_HALF_DUPLEX))
+		return false;
+	if (flags & BIT(TRIGGER_NETDEV_FULL_DUPLEX))
+		return false;
+
+	rx = flags & BIT(TRIGGER_NETDEV_RX);
+	tx = flags & BIT(TRIGGER_NETDEV_TX);
+
+	return rx == tx;
+}
+
+static int rtl8152_led_hw_control_is_supported(struct led_classdev *led_cdev,
+					       unsigned long flags)
+{
+	struct r8152_led_classdev *ldev = lcdev_to_r8152_ldev(led_cdev);
+	struct r8152 *tp = netdev_priv(ldev->ndev);
+	int shift = ldev->index * 4;
+
+	if (!r8152_trigger_mode_is_valid(flags)) {
+		/* Switch LED off to indicate that mode isn't supported */
+		r8152_led_mod_ctrl(tp, 0x000f << shift, 0);
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int rtl8152_led_hw_control_set(struct led_classdev *led_cdev,
+				      unsigned long flags)
+{
+	struct r8152_led_classdev *ldev = lcdev_to_r8152_ldev(led_cdev);
+	struct r8152 *tp = netdev_priv(ldev->ndev);
+	int shift = ldev->index * 4;
+	u16 mode = 0;
+
+	if (flags & BIT(TRIGGER_NETDEV_LINK_10))
+		mode |= RTL8152_LED_CTRL_LINK_10;
+	if (flags & BIT(TRIGGER_NETDEV_LINK_100))
+		mode |= RTL8152_LED_CTRL_LINK_100;
+	if (flags & BIT(TRIGGER_NETDEV_LINK_1000))
+		mode |= RTL8152_LED_CTRL_LINK_1000;
+	if (flags & BIT(TRIGGER_NETDEV_TX))
+		mode |= RTL8152_LED_CTRL_ACT;
+
+	return r8152_led_mod_ctrl(tp, 0x000f << shift, mode << shift);
+}
+
+static int rtl8152_led_hw_control_get(struct led_classdev *led_cdev,
+				      unsigned long *flags)
+{
+	struct r8152_led_classdev *ldev = lcdev_to_r8152_ldev(led_cdev);
+	struct r8152 *tp = netdev_priv(ldev->ndev);
+	int shift = ldev->index * 4;
+	int mode;
+
+	mode = rtl8152_get_led_mode(tp);
+	if (mode < 0)
+		return mode;
+
+	if (mode & RTL8152_LED_CTRL_OPTION2) {
+		r8152_led_mod_ctrl(tp, RTL8152_LED_CTRL_OPTION2, 0);
+		netdev_notice(ldev->ndev, "Deactivating unsupported Option2 LED mode\n");
+	}
+
+	mode = (mode >> shift) & 0x000f;
+
+	if (mode & RTL8152_LED_CTRL_ACT)
+		*flags |= BIT(TRIGGER_NETDEV_TX) | BIT(TRIGGER_NETDEV_RX);
+
+	if (mode & RTL8152_LED_CTRL_LINK_10)
+		*flags |= BIT(TRIGGER_NETDEV_LINK_10);
+	if (mode & RTL8152_LED_CTRL_LINK_100)
+		*flags |= BIT(TRIGGER_NETDEV_LINK_100);
+	if (mode & RTL8152_LED_CTRL_LINK_1000)
+		*flags |= BIT(TRIGGER_NETDEV_LINK_1000);
+
+	return 0;
+}
+
+static struct device *
+	r8152_led_hw_control_get_device(struct led_classdev *led_cdev)
+{
+	struct r8152_led_classdev *ldev = lcdev_to_r8152_ldev(led_cdev);
+
+	return &ldev->ndev->dev;
+}
+
+static void rtl8152_setup_ldev(struct r8152_led_classdev *ldev,
+			       struct net_device *ndev, int index)
+{
+	struct r8152 *tp = netdev_priv(ndev);
+	struct led_classdev *led_cdev = &ldev->led;
+	char led_name[LED_MAX_NAME_SIZE];
+
+	ldev->ndev = ndev;
+	ldev->index = index;
+
+	r8152_get_led_name(tp, index, led_name, LED_MAX_NAME_SIZE);
+	led_cdev->name = led_name;
+	led_cdev->hw_control_trigger = "netdev";
+	led_cdev->flags |= LED_RETAIN_AT_SHUTDOWN;
+	led_cdev->max_brightness = 1;
+	led_cdev->hw_control_is_supported = rtl8152_led_hw_control_is_supported;
+	led_cdev->hw_control_set = rtl8152_led_hw_control_set;
+	led_cdev->hw_control_get = rtl8152_led_hw_control_get;
+	led_cdev->hw_control_get_device = r8152_led_hw_control_get_device;
+
+	/* ignore errors */
+	led_classdev_register(&ndev->dev, led_cdev);
+}
+
+static struct r8152_led_classdev *rtl8152_init_leds(struct net_device *ndev)
+{
+	struct r8152_led_classdev *leds;
+	int i;
+
+	leds = kcalloc(RTL8152_NUM_LEDS + 1, sizeof(*leds), GFP_KERNEL);
+	if (!leds)
+		return NULL;
+
+	for (i = 0; i < RTL8152_NUM_LEDS; i++)
+		rtl8152_setup_ldev(leds + i, ndev, i);
+
+	return leds;
+}
+
+static void r8152_remove_leds(struct r8152_led_classdev *leds)
+{
+	if (!leds)
+		return;
+
+	for (struct r8152_led_classdev *l = leds; l->ndev; l++)
+		led_classdev_unregister(&l->led);
+
+	kfree(leds);
+}
+
 static void r8152b_init(struct r8152 *tp)
 {
 	u32 ocp_data;
@@ -9965,6 +10152,9 @@ static int rtl8152_probe_once(struct usb_interface *intf,
 		goto out1;
 	}
 
+	if (tp->version <= RTL_VER_09)
+		rtl8152_init_leds(tp->netdev);
+
 	if (tp->saved_wolopts)
 		device_set_wakeup_enable(&udev->dev, true);
 	else
@@ -10040,6 +10230,9 @@ static void rtl8152_disconnect(struct usb_interface *intf)
 	if (tp) {
 		rtl_set_unplug(tp);
 
+		if (tp->version <= RTL_VER_09)
+			r8152_remove_leds(tp->leds);
+
 		unregister_netdev(tp->netdev);
 		tasklet_kill(&tp->tx_tl);
 		cancel_delayed_work_sync(&tp->hw_phy_work);
-- 
2.39.5

