From 20e942142d5971b52998206c2d759203580df77f Mon Sep 17 00:00:00 2001
From: Aleksander Jan Bajkowski <olek2@wp.pl>
Date: Sun, 30 Apr 2023 22:31:35 +0200
Subject: [PATCH] net: dsa: mt753x: add LAG support

Add LAG support to this switch. In Documentation this is described as
trunk mode. A max of 3 LAGs are supported and each can support up to 2
port. The current tx mode supported is Hash mode.
When no port are present in the trunk, the trunk is disabled in the
switch.
When a port is disconnected, the traffic is redirected to the other
available port.
The hash mode is global and each LAG require to have the same hash mode
set. To change the hash mode when multiple LAG are configured, it's
required to remove each LAG and set the desired hash mode to the last.
An error is printed when it's asked to set a not supported hadh mode.

Signed-off-by: Aleksander Jan Bajkowski <olek2@wp.pl>
---
 drivers/net/dsa/mt7530.c | 195 +++++++++++++++++++++++++++++++++++++++
 drivers/net/dsa/mt7530.h |  26 ++++++
 2 files changed, 221 insertions(+)

diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
index 548b85befbf4..d1219c45ce4c 100644
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -1681,6 +1681,9 @@ mt7530_port_fdb_add(struct dsa_switch *ds, int port,
 	int ret;
 	u8 port_mask = BIT(port);
 
+	printk(KERN_ERR "%s port=%d, addr=%02hx:%02hx:%02hx:%02hx:%02hx:%02hx, vid=%u\n", __func__, port, addr[0],
+			addr[1], addr[2], addr[3], addr[4], addr[5], vid);
+
 	mutex_lock(&priv->reg_mutex);
 	mt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_ENT);
 	ret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);
@@ -1698,6 +1701,9 @@ mt7530_port_fdb_del(struct dsa_switch *ds, int port,
 	int ret;
 	u8 port_mask = BIT(port);
 
+	printk(KERN_ERR "%s port=%d, addr=%02hx:%02hx:%02hx:%02hx:%02hx:%02hx, vid=%u\n", __func__, port, addr[0],
+			addr[1], addr[2], addr[3], addr[4], addr[5], vid);
+
 	mutex_lock(&priv->reg_mutex);
 	mt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_EMP);
 	ret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);
@@ -1716,6 +1722,8 @@ mt7530_port_fdb_dump(struct dsa_switch *ds, int port,
 	int ret = 0;
 	u32 rsp = 0;
 
+	printk(KERN_ERR "%s port=%d\n", __func__, port);
+
 	mutex_lock(&priv->reg_mutex);
 
 	ret = mt7530_fdb_cmd(priv, MT7530_FDB_START, &rsp);
@@ -1726,6 +1734,8 @@ mt7530_port_fdb_dump(struct dsa_switch *ds, int port,
 		if (rsp & ATC_SRCH_HIT) {
 			mt7530_fdb_read(priv, &_fdb);
 			if (_fdb.port_mask & BIT(port)) {
+				printk(KERN_ERR "%s port=%d, addr=%02hx:%02hx:%02hx:%02hx:%02hx:%02hx, vid=%u, port_mask=%02x, aging=%u, noarp=%u\n", __func__, port, _fdb.mac[0],
+						_fdb.mac[1], _fdb.mac[2], _fdb.mac[3], _fdb.mac[4], _fdb.mac[5], _fdb.vid, _fdb.port_mask, _fdb.aging, _fdb.noarp);
 				ret = cb(_fdb.mac, _fdb.vid, _fdb.noarp,
 					 data);
 				if (ret < 0)
@@ -1741,6 +1751,27 @@ mt7530_port_fdb_dump(struct dsa_switch *ds, int port,
 	return 0;
 }
 
+static int
+mt7530_lag_fdb_add(struct dsa_switch *ds, struct dsa_lag lag,
+		   const unsigned char *addr, u16 vid,
+		   struct dsa_db db)
+{
+
+	printk(KERN_ERR "%s\n", __func__);
+
+	return 0;
+}
+
+static int
+mt7530_lag_fdb_del(struct dsa_switch *ds, struct dsa_lag lag,
+		   const unsigned char *addr, u16 vid,
+		   struct dsa_db db)
+{
+	printk(KERN_ERR "%s\n", __func__);
+
+	return 0;
+}
+
 static int
 mt7530_port_mdb_add(struct dsa_switch *ds, int port,
 		    const struct switchdev_obj_port_mdb *mdb,
@@ -2610,6 +2641,10 @@ mt7531_setup_common(struct dsa_switch *ds)
 			   PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT));
 	}
 
+	/* Disable learings on LAGs */
+	for (i = 0; i < MT7530_NUM_LAGS; i++)
+		mt7530_write(priv, MT7530_PTGSC(i), SA_CNT_EN);
+
 	/* Allow mirroring frames received on the local port (monitor port). */
 	mt7530_set(priv, MT753X_AGC, LOCAL_EN);
 
@@ -3137,9 +3172,164 @@ mt753x_setup(struct dsa_switch *ds)
 	if (ret && priv->irq_domain)
 		mt7530_free_mdio_irq(priv);
 
+	/* Set max number of LAGs supported */
+	ds->num_lag_ids = MT7530_NUM_LAGS;
+
 	return ret;
 }
 
+static bool mt753x_lag_can_offload(struct dsa_switch *ds,
+				   struct dsa_lag lag,
+				   struct netdev_lag_upper_info *info,
+				   struct netlink_ext_ack *extack)
+{
+	struct dsa_port *dp;
+	int members = 0;
+
+	if (!lag.id)
+		return false;
+
+	dsa_lag_foreach_port(dp, ds->dst, &lag)
+		/* Includes the port joining the LAG */
+		members++;
+
+	if (members > MT7530_NUM_PORTS_FOR_LAG) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Cannot offload more than 2 LAG ports");
+		return false;
+	}
+
+	if (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Can only offload LAG using hash TX type");
+		return false;
+	}
+
+	if (info->hash_type != NETDEV_LAG_HASH_L2 &&
+	    info->hash_type != NETDEV_LAG_HASH_L23 &&
+	    info->hash_type != NETDEV_LAG_HASH_L34) {
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Can only offload L2, L2+L3 or L3+L4 TX hash");
+		return false;
+	}
+
+	return true;
+}
+
+static int mt753x_lag_setup_hash(struct dsa_switch *ds,
+				 struct dsa_lag lag,
+				 struct netdev_lag_upper_info *info)
+{
+	struct net_device *lag_dev = lag.dev;
+	struct mt7530_priv *priv = ds->priv;
+	bool unique_lag = true;
+	unsigned int i;
+	u32 hash = 0;
+
+	switch (info->hash_type) {
+	case NETDEV_LAG_HASH_L34:
+		hash |= INFO_SEL_L4_SPORT;
+		hash |= INFO_SEL_L4_DPORT;
+		hash |= INFO_SEL_L3_SIP;
+		hash |= INFO_SEL_L3_DIP;
+		break;
+	case NETDEV_LAG_HASH_L23:
+		hash |= INFO_SEL_L3_SIP;
+		hash |= INFO_SEL_L3_DIP;
+		fallthrough;
+	case NETDEV_LAG_HASH_L2:
+		hash |= INFO_SEL_L2_SA;
+		hash |= INFO_SEL_L2_DA;
+		break;
+	default: /* We should NEVER reach this */
+		return -EOPNOTSUPP;
+	}
+
+	/* Check if we are the unique configured LAG */
+	dsa_lags_foreach_id(i, ds->dst)
+		if (i != lag.id && dsa_lag_by_id(ds->dst, i)) {
+			unique_lag = false;
+			break;
+		}
+
+	/* Hash Mode is global. Make sure the same Hash Mode
+	 * is set to all the 3 possible lag.
+	 * If we are the unique LAG we can set whatever hash
+	 * mode we want.
+	 * To change hash mode it's needed to remove all LAG
+	 * and change the mode with the latest.
+	 */
+	if (unique_lag) {
+		priv->lag_hash_mode = hash;
+	} else if (priv->lag_hash_mode != hash) {
+		netdev_err(lag_dev, "Error: Mismatched Hash Mode across different lag is not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	mt7530_rmw(priv, MT7530_PTC, INFO_SEL_MASK, hash);
+
+	return 0;
+}
+
+static int mt753x_lag_refresh_portmap(struct dsa_switch *ds, int port,
+				      struct dsa_lag lag)
+{
+	struct mt7530_priv *priv = ds->priv;
+	struct dsa_port *dp;
+	int members = 0;
+	u32 val = 0;
+	int id;
+
+	/* DSA LAG IDs are one-based, hardware is zero-based */
+	id = lag.id - 1;
+
+	dsa_lag_foreach_port(dp, ds->dst, &lag)
+		/* Includes the port joining the LAG */
+		val |= GRP_PORT(dp->index, members++);
+
+	if (members > 1)
+		val |= TRUNK_EN;
+
+	mt7530_write(priv, MT7530_PTGC(id), val);
+
+	return 0;
+}
+
+static int mt753x_port_lag_join(struct dsa_switch *ds, int port, struct dsa_lag lag,
+			 struct netdev_lag_upper_info *info,
+			 struct netlink_ext_ack *extack)
+{
+	int ret;
+
+	printk(KERN_ERR "%s: port=%d\n", __func__, port);
+
+	if (!mt753x_lag_can_offload(ds, lag, info, extack))
+		return -EOPNOTSUPP;
+
+	ret = mt753x_lag_setup_hash(ds, lag, info);
+	if (ret)
+		return ret;
+
+	return mt753x_lag_refresh_portmap(ds, port, lag);
+}
+
+static int mt753x_port_lag_leave(struct dsa_switch *ds, int port,
+			  struct dsa_lag lag)
+{
+	printk(KERN_ERR "%s: port=%d\n", __func__, port);
+
+	return mt753x_lag_refresh_portmap(ds, port, lag);
+}
+
+static int mt753x_port_lag_change(struct dsa_switch *ds, int port)
+{
+	struct dsa_port *dp = dsa_to_port(ds, port);
+
+	printk(KERN_ERR "%s: port=%d, enabled=%d\n", __func__, port, dp->lag_tx_enabled);
+
+	return 0;
+}
+
 static int mt753x_set_mac_eee(struct dsa_switch *ds, int port,
 			      struct ethtool_keee *e)
 {
@@ -3278,6 +3468,8 @@ const struct dsa_switch_ops mt7530_switch_ops = {
 	.port_fdb_add		= mt7530_port_fdb_add,
 	.port_fdb_del		= mt7530_port_fdb_del,
 	.port_fdb_dump		= mt7530_port_fdb_dump,
+	.lag_fdb_add		= mt7530_lag_fdb_add,
+	.lag_fdb_del		= mt7530_lag_fdb_del,
 	.port_mdb_add		= mt7530_port_mdb_add,
 	.port_mdb_del		= mt7530_port_mdb_del,
 	.port_vlan_filtering	= mt7530_port_vlan_filtering,
@@ -3286,6 +3478,9 @@ const struct dsa_switch_ops mt7530_switch_ops = {
 	.port_mirror_add	= mt753x_port_mirror_add,
 	.port_mirror_del	= mt753x_port_mirror_del,
 	.phylink_get_caps	= mt753x_phylink_get_caps,
+	.port_lag_join		= mt753x_port_lag_join,
+	.port_lag_leave		= mt753x_port_lag_leave,
+	.port_lag_change	= mt753x_port_lag_change,
 	.support_eee		= dsa_supports_eee,
 	.set_mac_eee		= mt753x_set_mac_eee,
 	.conduit_state_change	= mt753x_conduit_state_change,
diff --git a/drivers/net/dsa/mt7530.h b/drivers/net/dsa/mt7530.h
index 7e47cd9af256..2b3341d640c3 100644
--- a/drivers/net/dsa/mt7530.h
+++ b/drivers/net/dsa/mt7530.h
@@ -10,6 +10,8 @@
 #define MT7530_NUM_PHYS			5
 #define MT7530_NUM_FDB_RECORDS		2048
 #define MT7530_ALL_MEMBERS		0xff
+#define MT7530_NUM_LAGS			3
+#define MT7530_NUM_PORTS_FOR_LAG	2
 
 #define MTK_HDR_LEN	4
 #define MT7530_MAX_MTU	(15 * 1024 - ETH_HLEN - ETH_FCS_LEN - MTK_HDR_LEN)
@@ -253,6 +255,29 @@ enum mt7530_vlan_egress_attr {
 #define  AGE_UNIT_MAX			0xfff
 #define  AGE_UNIT(x)			(AGE_UNIT_MASK & (x))
 
+/* Registers for Link Aggregation / Trunking */
+#define MT7530_PTC			0x100
+#define  INFO_SEL_L4_DPORT		BIT(15)
+#define  INFO_SEL_L4_SPORT		BIT(14)
+#define  INFO_SEL_L3_DIP		BIT(13)
+#define  INFO_SEL_L3_SIP		BIT(12)
+#define  INFO_SEL_L2_DA			BIT(11)
+#define  INFO_SEL_L2_SA			BIT(10)
+#define  INFO_SEL_MASK			GENMASK(15, 9)
+
+#define MT7530_PTGC(x)			(0x108 + ((x) * 0x4))
+#define  GRP_PORT(x, y)			((x) << (4 * (y) + 8))
+#define  SA_LRN_PORT			GENMASK(5, 4)
+#define  SA_LRN_PORT_INGRESS		(0 << 4)
+#define  SA_LRN_PORT_GRP_PORT0		(1 << 4)
+#define  SA_LRN_PORT_GRP_PORT1		(2 << 4)
+#define  LINK_DOWN			BIT(1)
+#define  TRUNK_EN			BIT(0)
+
+#define MT7530_PTGSC(x)			(0x114 + ((x) * 0x4))
+#define  MAX_SA_CNT(x)			((x) << 3)
+#define  SA_CNT_EN			BIT(0)
+
 #define MT753X_ERLCR_P(x)		(0x1040 + ((x) * 0x100))
 #define  ERLCR_CIR_MASK			GENMASK(31, 16)
 #define  ERLCR_EN_MASK			BIT(15)
@@ -892,6 +917,7 @@ struct mt7530_priv {
 	bool			p5_sgmii;
 	u8			mirror_rx;
 	u8			mirror_tx;
+	u8			lag_hash_mode;
 	struct mt7530_port	ports[MT7530_NUM_PORTS];
 	struct mt753x_pcs	pcs[MT7530_NUM_PORTS];
 	/* protect among processes for registers access*/
-- 
2.47.3

