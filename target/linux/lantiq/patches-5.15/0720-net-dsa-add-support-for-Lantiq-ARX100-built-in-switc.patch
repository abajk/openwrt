From b7d2ee8cc0438e53e3a48cf92e422a1cbff45dd6 Mon Sep 17 00:00:00 2001
From: Aleksander Jan Bajkowski <olek2@wp.pl>
Date: Thu, 4 Nov 2021 23:15:35 +0100
Subject: [PATCH] net: dsa: add support for Lantiq ARX100 built-in switch

Provide basic support for Lantiq ARX100 built-in switch. So far it
works as port multiplexer without any hardware offloading support.

Signed-off-by: Aleksander Jan Bajkowski <olek2@wp.pl>
---
 .../bindings/net/dsa/lantiq,tantos.yaml       |  95 ++
 arch/mips/lantiq/xway/sysctrl.c               |   2 +-
 drivers/net/dsa/Kconfig                       |   8 +
 drivers/net/dsa/Makefile                      |   1 +
 drivers/net/dsa/lantiq_tantos.c               | 808 ++++++++++++++++++
 drivers/net/ethernet/lantiq_xrx200.c          |  43 +-
 include/net/dsa.h                             |   2 +
 net/dsa/Kconfig                               |   6 +
 net/dsa/Makefile                              |   1 +
 net/dsa/tag_tantos.c                          |  82 ++
 10 files changed, 1031 insertions(+), 17 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/net/dsa/lantiq,tantos.yaml
 create mode 100644 drivers/net/dsa/lantiq_tantos.c
 create mode 100644 net/dsa/tag_tantos.c

diff --git a/Documentation/devicetree/bindings/net/dsa/lantiq,tantos.yaml b/Documentation/devicetree/bindings/net/dsa/lantiq,tantos.yaml
new file mode 100644
index 000000000000..cd1a92dbe9c0
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/dsa/lantiq,tantos.yaml
@@ -0,0 +1,95 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/net/dsa/lantiq,tantos.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Lantiq Tantos Ethernet switches
+
+allOf:
+  - $ref: dsa.yaml#
+
+maintainers:
+  - Aleksander Jan Bajkowski <olek2@wp.pl>
+
+description:
+  Realtek advertises these chips as fast/gigabit switches or unmanaged
+  switches. They can be controlled using different interfaces, like SMI,
+  MDIO or SPI.
+
+properties:
+  compatible:
+    enum:
+      - lantiq,arx100-tantos
+
+  reg:
+    maxItems: 3
+
+  mdio:
+    $ref: /schemas/net/mdio.yaml#
+    unevaluatedProperties: false
+
+required:
+  - compatible
+  - reg
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    switch@e108000 {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            compatible = "lantiq,arx100-tantos";
+            reg = < 0xe108000 0x8c
+                    0xe1080c4 0x08
+                    0xe1080cc 0x08
+                    >;
+
+            dsa,member = <0 0>;
+
+            ports {
+                    #address-cells = <1>;
+                    #size-cells = <0>;
+
+                    port@0 {
+                            reg = <0>;
+                            label = "lan1";
+                            phy-mode = "rgmii";
+                            phy-handle = <&phy0>;
+                    };
+
+                    port@1 {
+                            reg = <1>;
+                            label = "lan2";
+                            phy-mode = "rmii";
+                            phy-handle = <&phy1>;
+                    };
+
+                    port@2 {
+                            reg = <0x2>;
+                            phy-mode = "internal";
+                            ethernet = <&eth0>;
+
+                            fixed-link {
+                                    speed = <1000>;
+                                    full-duplex;
+                            };
+                   };
+            };
+
+            mdio {
+                    #address-cells = <1>;
+                    #size-cells = <0>;
+                    compatible = "lantiq,arx100-mdio";
+                    reg = <0>;
+
+                    phy0: ethernet-phy@0 {
+                            reg = <0x0>;
+                    };
+
+                    phy1: ethernet-phy@1 {
+                            reg = <0x1>;
+                    };
+            };
+    };
diff --git a/arch/mips/lantiq/xway/sysctrl.c b/arch/mips/lantiq/xway/sysctrl.c
index d444a1b98a72..ceac86de37d3 100644
--- a/arch/mips/lantiq/xway/sysctrl.c
+++ b/arch/mips/lantiq/xway/sysctrl.c
@@ -574,7 +574,7 @@ void __init ltq_soc_init(void)
 		clkdev_add_pmu("1e101000.usb", "otg", 1, 0, PMU_USB0 | PMU_AHBM);
 		clkdev_add_pmu("1f203034.usb2-phy", "phy", 1, 0, PMU_USB1_P);
 		clkdev_add_pmu("1e106000.usb", "otg", 1, 0, PMU_USB1 | PMU_AHBM);
-		clkdev_add_pmu("1e180000.etop", "switch", 1, 0, PMU_SWITCH);
+		clkdev_add_pmu("1e10808c.eth", NULL, 0, 0, PMU_SWITCH);
 		clkdev_add_pmu("1e103000.sdio", NULL, 1, 0, PMU_SDIO);
 		clkdev_add_pmu("1e103100.deu", NULL, 1, 0, PMU_DEU);
 		clkdev_add_pmu("1e116000.mei", "dfe", 1, 0, PMU_DFE);
diff --git a/drivers/net/dsa/Kconfig b/drivers/net/dsa/Kconfig
index 07507b4820d7..1a404fb3502d 100644
--- a/drivers/net/dsa/Kconfig
+++ b/drivers/net/dsa/Kconfig
@@ -33,6 +33,14 @@ config NET_DSA_LANTIQ_GSWIP
 	  This enables support for the Lantiq / Intel GSWIP 2.1 found in
 	  the xrx200 / VR9 SoC.
 
+config NET_DSA_LANTIQ_TANTOS
+	tristate "Lantiq Tantos"
+	depends on HAS_IOMEM
+	select NET_DSA_TAG_TANTOS
+	help
+	  This enables support for the Lantiq Tantos switch found in
+	  the arx100 / AR9 SoC.
+
 config NET_DSA_MT7530
 	tristate "MediaTek MT753x and MT7621 Ethernet switch support"
 	select NET_DSA_TAG_MTK
diff --git a/drivers/net/dsa/Makefile b/drivers/net/dsa/Makefile
index 16eb879e0cb4..88a8881dc848 100644
--- a/drivers/net/dsa/Makefile
+++ b/drivers/net/dsa/Makefile
@@ -6,6 +6,7 @@ ifdef CONFIG_NET_DSA_LOOP
 obj-$(CONFIG_FIXED_PHY)		+= dsa_loop_bdinfo.o
 endif
 obj-$(CONFIG_NET_DSA_LANTIQ_GSWIP) += lantiq_gswip.o
+obj-$(CONFIG_NET_DSA_LANTIQ_TANTOS) += lantiq_tantos.o
 obj-$(CONFIG_NET_DSA_MT7530)	+= mt7530.o
 obj-$(CONFIG_NET_DSA_MV88E6060) += mv88e6060.o
 obj-$(CONFIG_NET_DSA_RZN1_A5PSW) += rzn1_a5psw.o
diff --git a/drivers/net/dsa/lantiq_tantos.c b/drivers/net/dsa/lantiq_tantos.c
new file mode 100644
index 000000000000..b45cb7464186
--- /dev/null
+++ b/drivers/net/dsa/lantiq_tantos.c
@@ -0,0 +1,808 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Lantiq Tantos switch driver for ARX100 SoCs
+ *
+ * Copyright (C) 2011 - 2012 John Crispin <john@phrozen.org>
+ * Copyright (C) 2021 - 2022 Aleksander Jan Bajkowski <olek2@wp.pl>
+ */
+
+#include <linux/clk.h>
+#include <linux/etherdevice.h>
+#include <linux/if_bridge.h>
+#include <linux/if_vlan.h>
+#include <linux/iopoll.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/of_platform.h>
+#include <linux/phy.h>
+#include <linux/phylink.h>
+#include <linux/platform_device.h>
+#include <linux/version.h> //temporary
+#include <net/dsa.h>
+
+/* Core Registers */
+#define ARX100_CTLp(p)			(0x004 + 4 * (p))
+#define  ARX100_CTL_DMDIO		BIT(22)
+#define  ARX100_CTL_DFWD		BIT(19)
+#define  ARX100_CTL_FLP			BIT(18)
+#define  ARX100_CTL_FLD			BIT(17)
+#define  ARX100_CTL_AD			BIT(15)
+#define  ARX100_CTL_LD			BIT(14)
+#define  ARX100_CTL_REDIR		BIT(13)
+
+#define ARX100_DF_PORTMAP		0x02C
+#define  ARX100_DF_PORTMAP_UP(p)	((p) << 24)
+#define  ARX100_DF_PORTMAP_BP(p)	((p) << 16)
+#define  ARX100_DF_PORTMAP_MP(p)	((p) << 8)
+#define  ARX100_DF_PORTMAP_RP(p)	((p) << 0)
+
+#define ARX100_GCTL0			0x068
+#define  ARX100_GCTL0_SE		BIT(31)
+#define  ARX100_GCTL0_MPL_MASK		GENMASK(9, 8)
+#define  ARX100_GCTL0_MPL_1522		(0x0 << 8)
+#define  ARX100_GCTL0_MPL_1518		(0x1 << 8)
+#define  ARX100_GCTL0_MPL_1536		(0x2 << 8)
+
+/* MDIO clock divider, clock = 25MHz/((MCS + 1) * 2) */
+#define ARX100_RGMII_CTL		0x078
+#define  ARX100_RGMII_CTL_MCS_SHIFT	24
+#define  ARX100_RGMII_CTL_MCS_MASK	GENMASK(31, 24)
+#define  ARX100_RGMII_CTL_CKIOp(p)	(0x1 << (((p) * 2) + 21))
+#define  ARX100_RGMII_CTL_FRQp(p)	(0x1 << (((p) * 2) + 20))
+#define  ARX100_RGMII_CTL_IS_MASKp(p)	(0x3 << (((p) * 10) + 8))
+#define  ARX100_RGMII_CTL_IS_RGMIIp(p)	(0x0 << (((p) * 10) + 8))
+#define  ARX100_RGMII_CTL_IS_MIIp(p)	(0x1 << (((p) * 10) + 8))
+#define  ARX100_RGMII_CTL_IS_REVMIIp(p)	(0x2 << (((p) * 10) + 8))
+#define  ARX100_RGMII_CTL_IS_RMIIp(p)	(0x3 << (((p) * 10) + 8))
+#define  ARX100_RGMII_CTL_RXDLY_MASKp(p)	(0x3 << (((p) * 10) + 6))
+#define  ARX100_RGMII_CTL_RXDLY_0p(p)		(0x0 << (((p) * 10) + 6))
+#define  ARX100_RGMII_CTL_RXDLY_1_5p(p)		(0x1 << (((p) * 10) + 6))
+#define  ARX100_RGMII_CTL_RXDLY_1_75p(p)	(0x2 << (((p) * 10) + 6))
+#define  ARX100_RGMII_CTL_RXDLY_2p(p)		(0x3 << (((p) * 10) + 6))
+#define  ARX100_RGMII_CTL_TXDLY_MASKp(p)	(0x3 << (((p) * 10) + 4))
+#define  ARX100_RGMII_CTL_TXDLY_0p(p)		(0x0 << (((p) * 10) + 4))
+#define  ARX100_RGMII_CTL_TXDLY_1_5p(p)		(0x1 << (((p) * 10) + 4))
+#define  ARX100_RGMII_CTL_TXDLY_1_75p(p)	(0x2 << (((p) * 10) + 4))
+#define  ARX100_RGMII_CTL_TXDLY_2p(p)		(0x3 << (((p) * 10) + 4))
+#define  ARX100_RGMII_CTL_SPD_MASKp(p)	(0x3 << (((p) * 10) + 2))
+#define  ARX100_RGMII_CTL_SPD_10p(p)	(0x0 << (((p) * 10) + 2))
+#define  ARX100_RGMII_CTL_SPD_100p(p)	(0x1 << (((p) * 10) + 2))
+#define  ARX100_RGMII_CTL_SPD_1000p(p)	(0x2 << (((p) * 10) + 2))
+#define  ARX100_RGMII_CTL_DUPp(p)	(0x1 << (((p) * 10) + 1))
+#define  ARX100_RGMII_CTL_FCEp(p)	(0x1 << (((p) * 10) + 0))
+
+/* RMON Registers */
+#define ARX100_RMON_CTL			0x000
+#define  ARX100_RMON_CTL_BUSY		BIT(11)
+#define  ARX100_RMON_CTL_CAC_MASK	GENMASK(10, 9)
+#define  ARX100_RMON_CTL_CAC_INDIR	(0x0 << 9)
+#define  ARX100_RMON_CTL_CAC_PORT_CNT	(0x1 << 9)
+#define  ARX100_RMON_CTL_CAC_PORT_RST	(0x2 << 9)
+#define  ARX100_RMON_CTL_CAC_ALL_RST	(0x3 << 9)
+#define  ARX100_RMON_CTL_PORTCp(p)	((p) << 6)
+#define  ARX100_RMON_CTL_OFFSET_MASK	GENMASK(5, 0)
+
+#define ARX100_RMON_DATA		0x004
+
+/* MDIO Registers */
+#define ARX100_MDIO_CTL			0x000
+#define  ARX100_MDIO_CTL_WR_SHIFT	16
+#define  ARX100_MDIO_CTL_WR_MASK	0xffff
+#define  ARX100_MDIO_CTL_MBUSY		BIT(15)
+#define  ARX100_MDIO_CTL_READ		BIT(11)
+#define  ARX100_MDIO_CTL_WRITE		BIT(10)
+#define  ARX100_MDIO_CTL_PHYAD_SHIFT	5
+#define  ARX100_MDIO_CTL_PHYAD_MASK	0x1f
+#define  ARX100_MDIO_CTL_REGAD_MASK	0x1f
+
+#define ARX100_MDIO_DATA		0x004
+#define  ARX100_MDIO_DATA_RD_MASK	GENMASK(15, 0)
+
+#define TANTOS_MAX_PACKET_LENGTH	1536
+
+struct tantos_hw_info {
+	int max_ports;
+	int cpu_port;
+	const struct dsa_switch_ops *ops;
+};
+
+struct tantos_priv {
+	__iomem void *core;
+	__iomem void *rmon;
+	__iomem void *mdio;
+	const struct tantos_hw_info *hw_info;
+	struct dsa_switch *ds;
+	struct device *dev;
+};
+
+struct tantos_rmon_cnt_desc {
+	unsigned int size;
+	unsigned int offset;
+	const char *name;
+};
+
+#define MIB_DESC(_size, _offset, _name) {.size = _size, .offset = _offset, .name = _name}
+
+static const struct tantos_rmon_cnt_desc tantos_rmon_cnt[] = {
+	/** Receive Packet Count (only packets that are accepted and not discarded). */
+	MIB_DESC(1, 0x00, "RxUnicastPkts"),
+	MIB_DESC(1, 0x01, "RxBroadcastPkts"),
+	MIB_DESC(1, 0x02, "RxMulticastPkts"),
+	MIB_DESC(1, 0x03, "RxFCSErrorPkts"),
+	MIB_DESC(1, 0x04, "RxUnderSizeGoodPkts"),
+	MIB_DESC(1, 0x05, "RxOversizeGoodPkts"),
+	MIB_DESC(1, 0x06, "RxUnderSizeErrorPkts"),
+	MIB_DESC(1, 0x07, "RxGoodPausePkts"),
+	MIB_DESC(1, 0x08, "RxOversizeErrorPkts"),
+	MIB_DESC(1, 0x09, "RxAlignErrorPkts"),
+	MIB_DESC(1, 0x0A, "FilteredPkts"),
+	MIB_DESC(1, 0x0B, "Rx64BytePkts"),
+	MIB_DESC(1, 0x0C, "Rx127BytePkts"),
+	MIB_DESC(1, 0x0D, "Rx255BytePkts"),
+	MIB_DESC(1, 0x0E, "Rx511BytePkts"),
+	MIB_DESC(1, 0x0F, "Rx1023BytePkts"),
+	/** Receive Size 1024-1522 (or more, if configured) Packet Count. */
+	MIB_DESC(1, 0x10, "RxMaxBytePkts"),
+	MIB_DESC(1, 0x11, "TxUnicastPkts"),
+	MIB_DESC(1, 0x12, "TxBroadcastPkts"),
+	MIB_DESC(1, 0x13, "TxMulticastPkts"),
+	MIB_DESC(1, 0x14, "TxSingleCollCount"),
+	MIB_DESC(1, 0x15, "TxMultCollCount"),
+	MIB_DESC(1, 0x16, "TxLateCollCount"),
+	MIB_DESC(1, 0x17, "TxExcessCollCount"),
+	MIB_DESC(1, 0x18, "TxCollCount"),
+	MIB_DESC(1, 0x19, "TxPauseCount"),
+	MIB_DESC(1, 0x1A, "Tx64BytePkts"),
+	MIB_DESC(1, 0x1B, "Tx127BytePkts"),
+	MIB_DESC(1, 0x1C, "Tx255BytePkts"),
+	MIB_DESC(1, 0x1D, "Tx511BytePkts"),
+	MIB_DESC(1, 0x1E, "Tx1023BytePkts"),
+	/** Transmit Size 1024-1522 (or more, if configured) Packet Count. */
+	MIB_DESC(1, 0x1F, "TxMaxBytePkts"),
+	MIB_DESC(1, 0x20, "TxDroppedPkts"),
+	MIB_DESC(1, 0x21, "RxDroppedPkts"),
+	MIB_DESC(2, 0x23, "RxGoodBytes"),
+	MIB_DESC(2, 0x25, "RxBadBytes"),
+	MIB_DESC(2, 0x27, "TxGoodBytes"),
+};
+
+static u32 tantos_switch_r(struct tantos_priv *priv, u32 offset)
+{
+	return __raw_readl(priv->core + offset);
+}
+
+static void tantos_switch_w(struct tantos_priv *priv, u32 val, u32 offset)
+{
+	__raw_writel(val, priv->core + offset);
+}
+
+static void tantos_switch_mask(struct tantos_priv *priv, u32 clear, u32 set,
+			       u32 offset)
+{
+	u32 val = tantos_switch_r(priv, offset);
+
+	val &= ~(clear);
+	val |= set;
+	tantos_switch_w(priv, val, offset);
+}
+
+static u32 tantos_rmon_r(struct tantos_priv *priv, u32 offset)
+{
+	return __raw_readl(priv->rmon + offset);
+}
+
+static void tantos_rmon_w(struct tantos_priv *priv, u32 val, u32 offset)
+{
+	__raw_writel(val, priv->rmon + offset);
+}
+
+static u32 tantos_rmon_r_timeout(struct tantos_priv *priv, u32 offset, u32 cleared)
+{
+	u32 val;
+
+	return readx_poll_timeout(__raw_readl, priv->rmon + offset, val,
+				  (val & cleared) == 0, 20, 50000);
+}
+
+static u32 tantos_mdio_r(struct tantos_priv *priv, u32 offset)
+{
+	return __raw_readl(priv->mdio + offset);
+}
+
+static void tantos_mdio_w(struct tantos_priv *priv, u32 val, u32 offset)
+{
+	__raw_writel(val, priv->mdio + offset);
+}
+
+static int tantos_mdio_poll(struct tantos_priv *priv)
+{
+	int cnt = 100;
+
+	while (likely(cnt--)) {
+		u32 ctrl = tantos_mdio_r(priv, ARX100_MDIO_CTL);
+
+		if ((ctrl & ARX100_MDIO_CTL_MBUSY) == 0)
+			return 0;
+		usleep_range(20, 40);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int tantos_mdio_wr(struct mii_bus *bus, int addr, int reg, u16 val)
+{
+	struct tantos_priv *priv = bus->priv;
+	int err;
+
+	err = tantos_mdio_poll(priv);
+	if (err) {
+		dev_err(&bus->dev, "waiting for MDIO bus busy timed out\n");
+		return err;
+	}
+
+	tantos_mdio_w(priv, ARX100_MDIO_CTL_MBUSY | ARX100_MDIO_CTL_WRITE |
+		((val & ARX100_MDIO_CTL_WR_MASK) << ARX100_MDIO_CTL_WR_SHIFT) |
+		((addr & ARX100_MDIO_CTL_PHYAD_MASK) << ARX100_MDIO_CTL_PHYAD_SHIFT) |
+		(reg & ARX100_MDIO_CTL_REGAD_MASK), ARX100_MDIO_CTL);
+
+	return 0;
+}
+
+static int tantos_mdio_rd(struct mii_bus *bus, int addr, int reg)
+{
+	struct tantos_priv *priv = bus->priv;
+	int err;
+
+	err = tantos_mdio_poll(priv);
+	if (err) {
+		dev_err(&bus->dev, "waiting for MDIO bus busy timed out\n");
+		return err;
+	}
+
+	tantos_mdio_w(priv, ARX100_MDIO_CTL_MBUSY | ARX100_MDIO_CTL_READ |
+		((addr & ARX100_MDIO_CTL_PHYAD_MASK) << ARX100_MDIO_CTL_PHYAD_SHIFT) |
+		(reg & ARX100_MDIO_CTL_REGAD_MASK), ARX100_MDIO_CTL);
+
+	err = tantos_mdio_poll(priv);
+	if (err) {
+		dev_err(&bus->dev, "waiting for MDIO bus busy timed out\n");
+		return err;
+	}
+
+	return tantos_mdio_r(priv, ARX100_MDIO_DATA) & ARX100_MDIO_DATA_RD_MASK;
+}
+
+static int tantos_mdio(struct tantos_priv *priv, struct device_node *mdio_np)
+{
+	struct dsa_switch *ds = priv->ds;
+	int err;
+
+	ds->slave_mii_bus = mdiobus_alloc();
+	if (!ds->slave_mii_bus)
+		return -ENOMEM;
+
+	ds->slave_mii_bus->priv = priv;
+	ds->slave_mii_bus->read = tantos_mdio_rd;
+	ds->slave_mii_bus->write = tantos_mdio_wr;
+	ds->slave_mii_bus->name = "lantiq,arx100-mdio";
+	snprintf(ds->slave_mii_bus->id, MII_BUS_ID_SIZE, "%s-mii",
+		 dev_name(priv->dev));
+	ds->slave_mii_bus->parent = priv->dev;
+	ds->slave_mii_bus->phy_mask = ~ds->phys_mii_mask;
+
+	err = of_mdiobus_register(ds->slave_mii_bus, mdio_np);
+	if (err)
+		mdiobus_free(ds->slave_mii_bus);
+
+	return err;
+}
+
+static int tantos_setup(struct dsa_switch *ds)
+{
+	struct tantos_priv *priv = ds->priv;
+	unsigned int cpu_port = priv->hw_info->cpu_port;
+	int i;
+
+	/* Enable switch */
+	tantos_switch_mask(priv, 0, ARX100_GCTL0_SE, ARX100_GCTL0);
+
+	/* Enable direct forwarding */
+	for (i = 0; i < priv->hw_info->max_ports; i++)
+		tantos_switch_mask(priv, 0, ARX100_CTL_DFWD, ARX100_CTLp(i));
+
+	/* Default unknown Broadcast/Multicast/Unicast port maps */
+	tantos_switch_w(priv, ARX100_DF_PORTMAP_UP(BIT(cpu_port)) |
+			ARX100_DF_PORTMAP_BP(BIT(cpu_port)) |
+			ARX100_DF_PORTMAP_MP(BIT(cpu_port)), ARX100_DF_PORTMAP);
+
+	/* Deactivate MDIO PHY auto polling. Some PHYs as the AR8030 have an
+	 * interoperability problem with this auto polling mechanism because
+	 * their status registers think that the link is in a different state
+	 * than it actually is. For the AR8030 it has the BMSR_ESTATEN bit set
+	 * as well as ESTATUS_1000_TFULL and ESTATUS_1000_XFULL. This makes the
+	 * auto polling state machine consider the link being negotiated with
+	 * 1Gbit/s. Since the PHY itself is a Fast Ethernet RMII PHY this leads
+	 * to the switch port being completely dead (RX and TX are both not
+	 * working).
+	 * Also with various other PHY / port combinations (PHY11G GPHY, PHY22F
+	 * GPHY, external RGMII PEF7071/7072) any traffic would stop. Sometimes
+	 * it would work fine for a few minutes to hours and then stop, on
+	 * other device it would no traffic could be sent or received at all.
+	 * Testing shows that when PHY auto polling is disabled these problems
+	 * go away.
+	 */
+	for (i = 0; i < priv->hw_info->max_ports; i++)
+		tantos_switch_mask(priv, 0, ARX100_CTL_DMDIO, ARX100_CTLp(i));
+
+	/* Configure the MDIO Clock 2.5 MHz */
+	tantos_switch_mask(priv, ARX100_RGMII_CTL_MCS_MASK,
+			(4 << ARX100_RGMII_CTL_MCS_SHIFT), ARX100_RGMII_CTL);
+
+	ds->mtu_enforcement_ingress = true;
+
+	return 0;
+}
+
+static int tantos_port_enable(struct dsa_switch *ds, int port,
+			      struct phy_device *phydev)
+{
+	struct tantos_priv *priv = ds->priv;
+
+	tantos_switch_mask(priv, ARX100_CTL_FLD, ARX100_CTL_FLP, ARX100_CTLp(port));
+
+	return 0;
+}
+
+static void tantos_port_disable(struct dsa_switch *ds, int port)
+{
+	struct tantos_priv *priv = ds->priv;
+
+	tantos_switch_mask(priv, ARX100_CTL_FLP, ARX100_CTL_FLD, ARX100_CTLp(port));
+}
+
+static enum dsa_tag_protocol tantos_get_tag_protocol(struct dsa_switch *ds,
+						     int port,
+						     enum dsa_tag_protocol mp)
+{
+	return DSA_TAG_PROTO_TANTOS;
+}
+
+static void tantos_port_set_speed(struct tantos_priv *priv, int port, int speed,
+				  phy_interface_t interface)
+{
+	u32 rgmii_ctl;
+
+	switch (speed) {
+	case SPEED_10:
+		rgmii_ctl = ARX100_RGMII_CTL_SPD_10p(port);
+		break;
+	case SPEED_100:
+		rgmii_ctl = ARX100_RGMII_CTL_SPD_100p(port);
+		break;
+	case SPEED_1000:
+		rgmii_ctl = ARX100_RGMII_CTL_SPD_1000p(port);
+		break;
+	}
+
+	tantos_switch_mask(priv, ARX100_RGMII_CTL_SPD_MASKp(port), rgmii_ctl, ARX100_RGMII_CTL);
+}
+
+static void tantos_port_set_duplex(struct tantos_priv *priv, int port, int duplex)
+{
+	if (duplex == DUPLEX_FULL)
+		tantos_switch_mask(priv, 0, ARX100_RGMII_CTL_DUPp(port), ARX100_RGMII_CTL);
+	else
+		tantos_switch_mask(priv, ARX100_RGMII_CTL_DUPp(port), 0, ARX100_RGMII_CTL);
+}
+
+static void tantos_port_set_pause(struct tantos_priv *priv, int port,
+				  bool tx_pause, bool rx_pause)
+{
+	if (tx_pause || rx_pause)
+		tantos_switch_mask(priv, 0, ARX100_RGMII_CTL_FCEp(port), ARX100_RGMII_CTL);
+	else
+		tantos_switch_mask(priv, ARX100_RGMII_CTL_FCEp(port), 0, ARX100_RGMII_CTL);
+}
+
+static int tantos_port_max_mtu(struct dsa_switch *ds, int port)
+{
+	/* Includes 8 bytes for special header. */
+	return TANTOS_MAX_PACKET_LENGTH - VLAN_ETH_HLEN - ETH_FCS_LEN;
+}
+
+static int tantos_port_change_mtu(struct dsa_switch *ds, int port, int new_mtu)
+{
+	struct tantos_priv *priv = ds->priv;
+	int cpu_port = priv->hw_info->cpu_port;
+	u32 mpl;
+
+	/* CPU port always has maximum mtu of user ports, so use it to set
+	 * switch frame size.
+	 */
+	if (port == cpu_port) {
+		new_mtu += (VLAN_ETH_HLEN + ETH_FCS_LEN);
+		if (new_mtu <= 1518)
+			mpl = ARX100_GCTL0_MPL_1518;
+		else if ((new_mtu > 1518) && (new_mtu <= 1522))
+			mpl = ARX100_GCTL0_MPL_1522;
+		else
+			mpl = ARX100_GCTL0_MPL_1536;
+
+		tantos_switch_mask(priv, ARX100_GCTL0_MPL_MASK, mpl, ARX100_GCTL0);
+	}
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5,17,0))
+static void tantos_phylink_get_caps(struct dsa_switch *ds, int port,
+				    struct phylink_config *config)
+{
+	switch (port) {
+	case 0:
+	case 1:
+		phy_interface_set_rgmii(config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_MII,
+			  config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_REVMII,
+			  config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_RMII,
+			  config->supported_interfaces);
+		break;
+	}
+
+	config->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |
+		MAC_10 | MAC_100 | MAC_1000;
+}
+#else
+static void tantos_phylink_validate(struct dsa_switch *ds, int port,
+				    unsigned long *supported,
+				    struct phylink_link_state *state)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+
+	switch (port) {
+	case 0:
+	case 1:
+		if (!phy_interface_mode_is_rgmii(state->interface) &&
+		    state->interface != PHY_INTERFACE_MODE_MII &&
+		    state->interface != PHY_INTERFACE_MODE_REVMII &&
+		    state->interface != PHY_INTERFACE_MODE_RMII)
+			goto unsupported;
+		break;
+	}
+
+	/* Allow all the expected bits */
+	phylink_set(mask, Autoneg);
+	phylink_set_port_modes(mask);
+	phylink_set(mask, Pause);
+	phylink_set(mask, Asym_Pause);
+
+	/* With the exclusion of MII, Reverse MII and Reduced MII, we
+	 * support Gigabit, including Half duplex
+	 */
+	if (state->interface != PHY_INTERFACE_MODE_MII &&
+	    state->interface != PHY_INTERFACE_MODE_REVMII &&
+	    state->interface != PHY_INTERFACE_MODE_RMII) {
+		phylink_set(mask, 1000baseT_Full);
+		phylink_set(mask, 1000baseT_Half);
+	}
+
+	phylink_set(mask, 10baseT_Half);
+	phylink_set(mask, 10baseT_Full);
+	phylink_set(mask, 100baseT_Half);
+	phylink_set(mask, 100baseT_Full);
+
+	linkmode_and(supported, supported, mask);
+	linkmode_and(state->advertising, state->advertising, mask);
+
+	return;
+
+unsupported:
+	linkmode_zero(supported);
+	dev_err(ds->dev, "Unsupported interface '%s' for port %d\n",
+		phy_modes(state->interface), port);
+}
+#endif
+
+static void tantos_phylink_mac_config(struct dsa_switch *ds, int port,
+				      unsigned int mode,
+				      const struct phylink_link_state *state)
+{
+	struct tantos_priv *priv = ds->priv;
+	u32 ctl = 0;
+
+	switch (state->interface) {
+	case PHY_INTERFACE_MODE_MII:
+		ctl |= ARX100_RGMII_CTL_IS_MIIp(port);
+		break;
+	case PHY_INTERFACE_MODE_REVMII:
+		ctl |= ARX100_RGMII_CTL_IS_REVMIIp(port);
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		ctl |= ARX100_RGMII_CTL_IS_RMIIp(port);
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		ctl |= ARX100_RGMII_CTL_IS_RGMIIp(port);
+		break;
+	default:
+		dev_err(ds->dev,
+			"Unsupported interface: %d\n", state->interface);
+		return;
+	}
+
+	tantos_switch_mask(priv, ARX100_RGMII_CTL_IS_MASKp(port), ctl, ARX100_RGMII_CTL);
+
+	switch (state->interface) {
+	case PHY_INTERFACE_MODE_RGMII:
+		tantos_switch_mask(priv, ARX100_RGMII_CTL_TXDLY_MASKp(port) |
+				   ARX100_RGMII_CTL_RXDLY_MASKp(port), 0, ARX100_RGMII_CTL);
+		break;
+	case PHY_INTERFACE_MODE_RGMII_ID:
+		tantos_switch_mask(priv, ARX100_RGMII_CTL_TXDLY_MASKp(port) |
+				   ARX100_RGMII_CTL_RXDLY_MASKp(port),
+				   ARX100_RGMII_CTL_TXDLY_1_75p(port) |
+				   ARX100_RGMII_CTL_RXDLY_1_75p(port), ARX100_RGMII_CTL);
+		break;
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+		tantos_switch_mask(priv, ARX100_RGMII_CTL_RXDLY_MASKp(port),
+				   ARX100_RGMII_CTL_RXDLY_1_75p(port), ARX100_RGMII_CTL);
+		break;
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		tantos_switch_mask(priv, ARX100_RGMII_CTL_TXDLY_MASKp(port),
+				   ARX100_RGMII_CTL_TXDLY_1_75p(port), ARX100_RGMII_CTL);
+		break;
+	default:
+		break;
+	}
+}
+
+static void tantos_phylink_mac_link_down(struct dsa_switch *ds, int port,
+					 unsigned int mode,
+					 phy_interface_t interface)
+{
+	if (!dsa_is_cpu_port(ds, port))
+		tantos_port_disable(ds, port);
+}
+
+static void tantos_phylink_mac_link_up(struct dsa_switch *ds, int port,
+				       unsigned int mode,
+				       phy_interface_t interface,
+				       struct phy_device *phydev,
+				       int speed, int duplex,
+				       bool tx_pause, bool rx_pause)
+{
+	struct tantos_priv *priv = ds->priv;
+
+	if (!dsa_is_cpu_port(ds, port)) {
+		tantos_port_set_speed(priv, port, speed, interface);
+		tantos_port_set_duplex(priv, port, duplex);
+		tantos_port_set_pause(priv, port, tx_pause, rx_pause);
+		tantos_port_enable(ds, port, NULL);
+	}
+}
+
+static void tantos_get_strings(struct dsa_switch *ds, int port, u32 stringset,
+			       uint8_t *data)
+{
+	int i;
+
+	if (stringset != ETH_SS_STATS)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(tantos_rmon_cnt); i++)
+		strncpy(data + i * ETH_GSTRING_LEN, tantos_rmon_cnt[i].name,
+			ETH_GSTRING_LEN);
+}
+
+static u32 tantos_rmon_entry_read(struct tantos_priv *priv, u32 table,
+				  u32 index)
+{
+	u32 result = 0;
+
+	if (tantos_rmon_r_timeout(priv, ARX100_RMON_CTL, ARX100_RMON_CTL_BUSY))
+		return result;
+
+	tantos_rmon_w(priv, (ARX100_RMON_CTL_BUSY | ARX100_RMON_CTL_PORTCp(table) |
+			     index), ARX100_RMON_CTL);
+
+	if (tantos_rmon_r_timeout(priv, ARX100_RMON_CTL, ARX100_RMON_CTL_BUSY))
+		return result;
+
+	result = tantos_rmon_r(priv, ARX100_RMON_DATA);
+
+	return result;
+}
+
+static void tantos_get_ethtool_stats(struct dsa_switch *ds, int port,
+				     uint64_t *data)
+{
+	struct tantos_priv *priv = ds->priv;
+	const struct tantos_rmon_cnt_desc *rmon_cnt;
+	u64 high;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tantos_rmon_cnt); i++) {
+		rmon_cnt = &tantos_rmon_cnt[i];
+
+		data[i] = tantos_rmon_entry_read(priv, port, rmon_cnt->offset);
+
+		if (rmon_cnt->size == 2) {
+			high = tantos_rmon_entry_read(priv, port,
+						      rmon_cnt->offset - 1);
+			data[i] |= high << 32;
+		}
+	}
+}
+
+static int tantos_get_sset_count(struct dsa_switch *ds, int port, int sset)
+{
+	if (sset != ETH_SS_STATS)
+		return 0;
+
+	return ARRAY_SIZE(tantos_rmon_cnt);
+}
+
+static const struct dsa_switch_ops tantos_arx100_switch_ops = {
+	.get_tag_protocol	= tantos_get_tag_protocol,
+	.setup			= tantos_setup,
+	.port_enable		= tantos_port_enable,
+	.port_disable		= tantos_port_disable,
+	.port_change_mtu	= tantos_port_change_mtu,
+	.port_max_mtu		= tantos_port_max_mtu,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5,17,0))
+	.phylink_get_caps	= tantos_phylink_get_caps,
+#else
+	.phylink_validate	= tantos_phylink_validate,
+#endif
+	.phylink_mac_config	= tantos_phylink_mac_config,
+	.phylink_mac_link_down	= tantos_phylink_mac_link_down,
+	.phylink_mac_link_up	= tantos_phylink_mac_link_up,
+	.get_strings		= tantos_get_strings,
+	.get_ethtool_stats	= tantos_get_ethtool_stats,
+	.get_sset_count		= tantos_get_sset_count,
+};
+
+static int tantos_probe(struct platform_device *pdev)
+{
+	struct tantos_priv *priv;
+	struct device_node *np, *mdio_np;
+	struct device *dev = &pdev->dev;
+	int err;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->core = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->core))
+		return PTR_ERR(priv->core);
+
+	priv->rmon = devm_platform_ioremap_resource(pdev, 1);
+	if (IS_ERR(priv->rmon))
+		return PTR_ERR(priv->rmon);
+
+	priv->mdio = devm_platform_ioremap_resource(pdev, 2);
+	if (IS_ERR(priv->mdio))
+		return PTR_ERR(priv->mdio);
+
+	priv->hw_info = of_device_get_match_data(dev);
+	if (!priv->hw_info)
+		return -EINVAL;
+
+	priv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);
+	if (!priv->ds)
+		return -ENOMEM;
+
+	priv->ds->dev = dev;
+	priv->ds->num_ports = priv->hw_info->max_ports;
+	priv->ds->priv = priv;
+	priv->ds->ops = priv->hw_info->ops;
+	priv->dev = dev;
+
+	np = dev->of_node;
+
+	/* Bring up the mdio bus */
+	mdio_np = of_get_compatible_child(dev->of_node, "lantiq,arx100-mdio");
+	if (mdio_np) {
+		err = tantos_mdio(priv, mdio_np);
+		if (err) {
+			dev_err(dev, "mdio probe failed\n");
+			goto put_mdio_node;
+		}
+	}
+
+	err = dsa_register_switch(priv->ds);
+	if (err) {
+		dev_err(dev, "dsa switch register failed: %i\n", err);
+		goto mdio_bus;
+	}
+	if (!dsa_is_cpu_port(priv->ds, priv->hw_info->cpu_port)) {
+		dev_err(dev, "wrong CPU port defined, HW only supports port: %i",
+			priv->hw_info->cpu_port);
+		err = -EINVAL;
+		goto disable_switch;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	dev_info(dev, "probed embedded Tantos");
+	return 0;
+
+disable_switch:
+	tantos_switch_mask(priv, ARX100_GCTL0_SE, 0, ARX100_GCTL0);
+	dsa_unregister_switch(priv->ds);
+mdio_bus:
+	if (mdio_np) {
+		mdiobus_unregister(priv->ds->slave_mii_bus);
+		mdiobus_free(priv->ds->slave_mii_bus);
+	}
+put_mdio_node:
+	of_node_put(mdio_np);
+	return err;
+}
+
+static int tantos_remove(struct platform_device *pdev)
+{
+	struct tantos_priv *priv = platform_get_drvdata(pdev);
+
+	if (!priv)
+		return 0;
+
+	/* Disable the switch */
+	tantos_switch_mask(priv, ARX100_GCTL0_SE, 0, ARX100_GCTL0);
+
+	dsa_unregister_switch(priv->ds);
+
+	if (priv->ds->slave_mii_bus) {
+		mdiobus_unregister(priv->ds->slave_mii_bus);
+		of_node_put(priv->ds->slave_mii_bus->dev.of_node);
+	}
+
+	return 0;
+}
+
+static void tantos_shutdown(struct platform_device *pdev)
+{
+	struct tantos_priv *priv = platform_get_drvdata(pdev);
+
+	if (!priv)
+		return;
+
+	dsa_switch_shutdown(priv->ds);
+
+	platform_set_drvdata(pdev, NULL);
+}
+
+static const struct tantos_hw_info tantos_arx100 = {
+	.max_ports = 3,
+	.cpu_port = 2,
+	.ops = &tantos_arx100_switch_ops,
+};
+
+static const struct of_device_id tantos_of_match[] = {
+	{ .compatible = "lantiq,arx100-tantos", .data = &tantos_arx100 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, tantos_of_match);
+
+static struct platform_driver tantos_driver = {
+	.probe = tantos_probe,
+	.remove = tantos_remove,
+	.shutdown = tantos_shutdown,
+	.driver = {
+		.name = "tantos",
+		.of_match_table = tantos_of_match,
+	},
+};
+
+module_platform_driver(tantos_driver);
+
+MODULE_AUTHOR("Aleksander Jan Bajkowski <olek2@wp.pl>");
+MODULE_DESCRIPTION("Lantiq Tantos switch driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/lantiq_xrx200.c b/drivers/net/ethernet/lantiq_xrx200.c
index 8d646c7f8c82..c464c317639d 100644
--- a/drivers/net/ethernet/lantiq_xrx200.c
+++ b/drivers/net/ethernet/lantiq_xrx200.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Lantiq / Intel PMAC driver for XRX200 SoCs
+ * Lantiq / Intel Pseudo MAC driver for ARX100 and XRX200 SoCs
  *
  * Copyright (C) 2010 Lantiq Deutschland
  * Copyright (C) 2012 John Crispin <john@phrozen.org>
@@ -13,6 +13,7 @@
 #include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/reset.h>
 
 #include <linux/if_vlan.h>
 
@@ -31,7 +32,7 @@
 #define XRX200_DMA_PACKET_IN_PROGRESS	1
 
 /* cpu port mac */
-#define PMAC_RX_IPG		0x0024
+#define PMAC_RX_IPG		0x001c
 #define PMAC_RX_IPG_MASK	0xf
 
 #define PMAC_HD_CTL		0x0000
@@ -40,23 +41,15 @@
 /* Add VLAN tag to Packets from DMA to PMAC */
 #define PMAC_HD_CTL_TAG		BIT(1)
 /* Add CRC to packets from DMA to PMAC */
-#define PMAC_HD_CTL_AC		BIT(2)
+#define PMAC_HD_CTL_AC		BIT(18)
 /* Add status header to packets from PMAC to DMA */
-#define PMAC_HD_CTL_AS		BIT(3)
+#define PMAC_HD_CTL_AS		BIT(19)
 /* Remove CRC from packets from PMAC to DMA */
-#define PMAC_HD_CTL_RC		BIT(4)
+#define PMAC_HD_CTL_RC		BIT(20)
 /* Remove Layer-2 header from packets from PMAC to DMA */
-#define PMAC_HD_CTL_RL2		BIT(5)
+#define PMAC_HD_CTL_RL2		BIT(21)
 /* Status header is present from DMA to PMAC */
-#define PMAC_HD_CTL_RXSH	BIT(6)
-/* Add special tag from PMAC to switch */
-#define PMAC_HD_CTL_AST		BIT(7)
-/* Remove specail Tag from PMAC to DMA */
-#define PMAC_HD_CTL_RST		BIT(8)
-/* Check CRC from DMA to PMAC */
-#define PMAC_HD_CTL_CCRC	BIT(9)
-/* Enable reaction to Pause frames in the PMAC */
-#define PMAC_HD_CTL_FC		BIT(10)
+#define PMAC_HD_CTL_RXSH	BIT(22)
 
 struct xrx200_chan {
 	int tx_free;
@@ -77,6 +70,7 @@ struct xrx200_chan {
 
 struct xrx200_priv {
 	struct clk *clk;
+	struct reset_control *switch_reset;
 
 	struct xrx200_chan chan_tx;
 	struct xrx200_chan chan_rx;
@@ -589,6 +583,11 @@ static int xrx200_probe(struct platform_device *pdev)
 	if (priv->chan_tx.dma.irq < 0)
 		return -ENOENT;
 
+	/* get the reset */
+	priv->switch_reset = devm_reset_control_get_exclusive(dev, "switch");
+	if (IS_ERR(priv->switch_reset))
+		return PTR_ERR(priv->switch_reset);
+
 	/* get the clock */
 	priv->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(priv->clk)) {
@@ -610,15 +609,26 @@ static int xrx200_probe(struct platform_device *pdev)
 	if (err)
 		goto err_uninit_dma;
 
+	err = reset_control_assert(priv->switch_reset);
+	if (err)
+		goto err_uninit_dma;
+
+	udelay(1);
+
+	err = reset_control_deassert(priv->switch_reset);
+	if (err)
+		goto err_uninit_dma;
+
 	/* set IPG to 12 */
 	xrx200_pmac_mask(priv, PMAC_RX_IPG_MASK, 0xb, PMAC_RX_IPG);
 
 	/* enable status header, enable CRC */
 	xrx200_pmac_mask(priv, 0,
-			 PMAC_HD_CTL_RST | PMAC_HD_CTL_AST | PMAC_HD_CTL_RXSH |
 			 PMAC_HD_CTL_AS | PMAC_HD_CTL_AC | PMAC_HD_CTL_RC,
 			 PMAC_HD_CTL);
 
+	// TODO: Set PMAC_HD_CTL_RXSH
+
 	/* setup NAPI */
 	netif_napi_add(net_dev, &priv->chan_rx.napi, xrx200_poll_rx);
 	netif_napi_add_tx(net_dev, &priv->chan_tx.napi,
@@ -664,6 +674,7 @@ static int xrx200_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id xrx200_match[] = {
+	{ .compatible = "lantiq,arx100-net" },
 	{ .compatible = "lantiq,xrx200-net" },
 	{},
 };
diff --git a/include/net/dsa.h b/include/net/dsa.h
index ee369670e20e..bd9d416378b8 100644
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -38,6 +38,7 @@ struct phylink_link_state;
 #define DSA_TAG_PROTO_LAN9303_VALUE		8
 #define DSA_TAG_PROTO_MTK_VALUE			9
 #define DSA_TAG_PROTO_QCA_VALUE			10
+#define DSA_TAG_PROTO_TANTOS_VALUE		28
 #define DSA_TAG_PROTO_TRAILER_VALUE		11
 #define DSA_TAG_PROTO_8021Q_VALUE		12
 #define DSA_TAG_PROTO_SJA1105_VALUE		13
@@ -69,6 +70,7 @@ enum dsa_tag_protocol {
 	DSA_TAG_PROTO_LAN9303		= DSA_TAG_PROTO_LAN9303_VALUE,
 	DSA_TAG_PROTO_MTK		= DSA_TAG_PROTO_MTK_VALUE,
 	DSA_TAG_PROTO_QCA		= DSA_TAG_PROTO_QCA_VALUE,
+	DSA_TAG_PROTO_TANTOS		= DSA_TAG_PROTO_TANTOS_VALUE,
 	DSA_TAG_PROTO_TRAILER		= DSA_TAG_PROTO_TRAILER_VALUE,
 	DSA_TAG_PROTO_8021Q		= DSA_TAG_PROTO_8021Q_VALUE,
 	DSA_TAG_PROTO_SJA1105		= DSA_TAG_PROTO_SJA1105_VALUE,
diff --git a/net/dsa/Kconfig b/net/dsa/Kconfig
index 3eef72ce99a4..9e75cce679d9 100644
--- a/net/dsa/Kconfig
+++ b/net/dsa/Kconfig
@@ -154,6 +154,12 @@ config NET_DSA_TAG_SJA1105
 	  is only for link-local traffic) as well as non-native tagging (based
 	  on a custom 802.1Q VLAN header) are available.
 
+config NET_DSA_TAG_TANTOS
+	tristate "Tag driver for Lantiq Tantos switches"
+	help
+	  Say Y or M if you want to enable support for tagging frames for the
+	  Lantiq Tantos switches.
+
 config NET_DSA_TAG_TRAILER
 	tristate "Tag driver for switches using a trailer tag"
 	help
diff --git a/net/dsa/Makefile b/net/dsa/Makefile
index bf57ef3bce2a..7e3b7f5f0750 100644
--- a/net/dsa/Makefile
+++ b/net/dsa/Makefile
@@ -27,5 +27,6 @@ obj-$(CONFIG_NET_DSA_TAG_RTL4_A) += tag_rtl4_a.o
 obj-$(CONFIG_NET_DSA_TAG_RTL8_4) += tag_rtl8_4.o
 obj-$(CONFIG_NET_DSA_TAG_RZN1_A5PSW) += tag_rzn1_a5psw.o
 obj-$(CONFIG_NET_DSA_TAG_SJA1105) += tag_sja1105.o
+obj-$(CONFIG_NET_DSA_TAG_TANTOS) += tag_tantos.o
 obj-$(CONFIG_NET_DSA_TAG_TRAILER) += tag_trailer.o
 obj-$(CONFIG_NET_DSA_TAG_XRS700X) += tag_xrs700x.o
diff --git a/net/dsa/tag_tantos.c b/net/dsa/tag_tantos.c
new file mode 100644
index 000000000000..3799ea987954
--- /dev/null
+++ b/net/dsa/tag_tantos.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Lantiq Tantos PMAC tag support
+ *
+ * Copyright (C) 2021 - 2022 Aleksander Jan Bajkowski <olek2@wp.pl>
+ */
+
+#include <linux/bitops.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/dsa.h>
+
+#include "dsa_priv.h"
+
+#define TANTOS_TX_HEADER_LEN		4
+
+/* special tag in TX path header */
+/* Byte 0 */
+#define TANTOS_TX_SLPID_SHIFT		0	/* source port ID */
+#define  TANTOS_TX_SLPID_CPU		2
+
+/* Byte 3 */
+#define TANTOS_TX_DPID_EN		BIT(0)
+
+#define TANTOS_RX_HEADER_LEN	8
+
+/* special tag in RX path header */
+/* Byte 2 */
+#define TANTOS_RX_SPPID_SHIFT		5
+#define TANTOS_RX_SPPID_MASK		GENMASK(7, 5)
+
+static struct sk_buff *tantos_tag_xmit(struct sk_buff *skb,
+				       struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	u8 *tantos_tag;
+
+	skb_push(skb, TANTOS_TX_HEADER_LEN);
+
+	tantos_tag = skb->data;
+	tantos_tag[0] = TANTOS_TX_SLPID_CPU;
+	tantos_tag[1] = dp->index;
+	tantos_tag[3] = TANTOS_TX_DPID_EN;
+
+	return skb;
+}
+
+static struct sk_buff *tantos_tag_rcv(struct sk_buff *skb,
+				      struct net_device *dev)
+{
+	int port;
+	u8 *tantos_tag;
+
+	if (unlikely(!pskb_may_pull(skb, TANTOS_RX_HEADER_LEN)))
+		return NULL;
+
+	tantos_tag = skb->data - ETH_HLEN;
+
+	/* Get source port information */
+	port = (tantos_tag[2] & TANTOS_RX_SPPID_MASK) >> TANTOS_RX_SPPID_SHIFT;
+	skb->dev = dsa_master_find_slave(dev, 0, port);
+	if (!skb->dev)
+		return NULL;
+
+	/* remove Tantos tag */
+	skb_pull_rcsum(skb, TANTOS_RX_HEADER_LEN);
+
+	return skb;
+}
+
+static const struct dsa_device_ops tantos_netdev_ops = {
+	.name = "tantos",
+	.proto	= DSA_TAG_PROTO_TANTOS,
+	.xmit = tantos_tag_xmit,
+	.rcv = tantos_tag_rcv,
+	.needed_headroom = TANTOS_RX_HEADER_LEN,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_TANTOS);
+
+module_dsa_tag_driver(tantos_netdev_ops);
-- 
2.30.2

